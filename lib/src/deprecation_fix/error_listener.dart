part of antlr4dart.deprecation_fix;

/**
 * How to emit recognition errors.
 * 
 * Use [Recognizer.onError].listen instead. See [Recognizer] documentation for
 * details on removing deprecated code.
 */  
class ErrorListener {
  /// Upon syntax error, notify any interested parties. This is not how to
  /// recover from errors or compute error messages. [ErrorStrategy]
  /// specifies how to recover from syntax errors and how to compute error
  /// messages. This listener's job is simply to emit a computed message,
  /// though it has enough information to create its own message in many cases.
  ///
  /// The [RecognitionException] is non-null for all syntax errors except
  /// when we discover mismatched token errors that we can recover from
  /// in-line, without returning from the surrounding rule (via the single
  /// token insertion and deletion mechanism).
  ///
  /// [recognizer] is the parser where got the error. From this object, you can
  /// access the context as well as the input source.
  /// [offendingSymbol] is the offending token in the input token source,
  /// unless recognizer is a lexer (then it's `null`). If no viable alternative
  /// error, [exception] has token at which we started production for the
  /// decision.
  /// [line] is the line number in the input where the error occurred.
  /// [charPositionInLine] is the character position within that line where
  /// the error occurred.
  /// [message] is the message to emit.
  /// [exception] is the exception generated by the parser that led to the
  /// reporting of an error. It is `null` in the case where the parser was
  /// able to recover in line without exiting the surrounding rule.
  void syntaxError(Recognizer recognizer,
                   Object offendingSymbol,
                   int line,
                   int charPositionInLine,
                   String message,
                   RecognitionException exception) {}

  /// This method is called by the parser when a full-context prediction
  /// results in an ambiguity.
  ///
  /// When [exact] is `true`, **all** of the alternatives in [ambigAlts] are
  /// viable, i.e. this is reporting an exact ambiguity.
  /// [exact] is `false`, **at least two** of the alternatives in [ambigAlts]
  /// are viable for the current input, but the prediction algorithm terminated
  /// as soon as it determined that at least the **minimum** alternative in
  /// [ambigAlts] is viable.
  ///
  /// When the [PredictionMode.LL_EXACT_AMBIG_DETECTION] prediction mode
  /// is used, the parser is required to identify exact ambiguities so
  /// [exact] will always be `true`.
  ///
  /// This method is not used by lexers.
  ///
  /// [recognizer] is the parser instance.
  /// [dfa] is the DFA for the current decision.
  /// [startIndex] is the input index where the decision started.
  /// [stopIndex] is the input input where the ambiguity is reported.
  /// [exact] is `true` if the ambiguity is exactly known, otherwise `false`.
  /// This is always `true` when [PredictionMode.LL_EXACT_AMBIG_DETECTION]
  /// is used.
  /// [ambigAlts] is the potentially ambiguous alternatives.
  /// [configs] is the ATN configuration set where the ambiguity was
  /// determined.
  void reportAmbiguity(Parser recognizer,
                       Dfa dfa,
                       int startIndex,
                       int stopIndex,
                       bool exact,
                       BitSet ambigAlts,
                       AtnConfigSet configs) {}

  /// This method is called when an SLL conflict occurs and the parser is about
  /// to use the full context information to make an LL decision.
  ///
  /// If one or more configurations in [configs] contains a semantic
  /// predicate, the predicates are evaluated before this method is called.
  /// The subset of alternatives which are still viable after predicates are
  /// evaluated is reported in [conflictingAlts].
  ///
  /// This method is not used by lexers.
  ///
  /// [recognizer] is the parser instance.
  /// [dfa] is the DFA for the current decision.
  /// [startIndex] is the input index where the decision started.
  /// [stopIndex] is the input index where the SLL conflict occurred.
  /// [conflictingAlts] is the specific conflicting alternatives. If this is
  /// `null`, the conflicting alternatives are all alternatives represented
  /// in [configs].
  /// [configs] is the ATN configuration set where the SLL conflict was
  /// detected.
  void reportAttemptingFullContext(Parser recognizer,
                                   Dfa dfa,
                                   int startIndex,
                                   int stopIndex,
                                   BitSet conflictingAlts,
                                   AtnConfigSet configs) {}

  /// This method is called by the parser when a full-context prediction has a
  /// unique result.
  ///
  /// For prediction implementations that only evaluate full-context
  /// predictions when an SLL conflict is found (including the default
  /// [ParserAtnSimulator] implementation), this method reports cases
  /// where SLL conflicts were resolved to unique full-context predictions,
  /// i.e. the decision was context-sensitive. This report does not necessarily
  /// indicate a problem, and it may appear even in completely unambiguous
  /// grammars.
  ///
  /// [configs] may have more than one represented alternative if the
  /// full-context prediction algorithm does not evaluate predicates before
  /// beginning the full-context prediction. In all cases, the final prediction
  /// is passed as the [prediction] argument.
  ///
  /// This method is not used by lexers.
  ///
  /// [recognizer] is the parser instance.
  /// [dfa] is the DFA for the current decision.
  /// [startIndex] the input index where the decision started.
  /// [stopIndex] is the input index where the context sensitivity was
  /// finally determined.
  /// [prediction] is the unambiguous result of the full-context prediction.
  /// [configs] is the ATN configuration set where the unambiguous prediction
  /// was determined.
  void reportContextSensitivity(Parser recognizer,
                                Dfa dfa,
                                int startIndex,
                                int stopIndex,
                                int prediction,
                                AtnConfigSet configs) {}
}

class ConsoleErrorListener extends ErrorListener {

  static final ConsoleErrorListener INSTANCE = new ConsoleErrorListener();

  void syntaxError(Recognizer recognizer,
                   Object offendingSymbol,
                   int line,
                   int charPositionInLine,
                   String msg,
                   RecognitionException e) {
    print("line $line:$charPositionInLine $msg");
  }
}

//// This implementation of [ErrorListener] dispatches all calls to a
//// collection of delegate listeners. This reduces the effort required
//// to support multiple listeners.
class ProxyErrorListener implements ErrorListener {
  final Iterable delegates;

  ProxyErrorListener(this.delegates) {
    assert(delegates != null);
  }

  void syntaxError(Recognizer recognizer,
                   Object offendingSymbol,
                   int line,
                   int charPositionInLine,
                   String message,
                   RecognitionException exception) {
    delegates.forEach((delegate) {
      delegate.syntaxError(recognizer,
                           offendingSymbol,
                           line,
                           charPositionInLine,
                           message,
                           exception);
      });
  }

  void reportAmbiguity(Parser recognizer,
                       Dfa dfa,
                       int startIndex,
                       int stopIndex,
                       bool exact,
                       BitSet ambigAlts,
                       AtnConfigSet configs) {
    delegates.forEach((delegate) {
      delegate.reportAmbiguity(recognizer,
                               dfa,
                               startIndex,
                               stopIndex,
                               exact,
                               ambigAlts,
                               configs);
    });
  }

  void reportAttemptingFullContext(Parser recognizer,
                                   Dfa dfa,
                                   int startIndex,
                                   int stopIndex,
                                   BitSet conflictingAlts,
                                   AtnConfigSet configs) {
    delegates.forEach((delegate) {
      delegate.reportAttemptingFullContext(recognizer,
                                           dfa,
                                           startIndex,
                                           stopIndex,
                                           conflictingAlts,
                                           configs);
    });
  }

  void reportContextSensitivity(Parser recognizer,
                                Dfa dfa,
                                int startIndex,
                                int stopIndex,
                                int prediction,
                                AtnConfigSet configs) {
    delegates.forEach((delegate) {
      delegate.reportContextSensitivity(recognizer,
                                        dfa,
                                        startIndex,
                                        stopIndex,
                                        prediction,
                                        configs);
    });
  }
}